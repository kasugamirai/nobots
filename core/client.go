// Code generated by ent, DO NOT EDIT.

package core

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"freefrom.space/nobot/core/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"freefrom.space/nobot/core/botevents"
	"freefrom.space/nobot/core/events"
	"freefrom.space/nobot/core/nostrnotesfetchhistory"
	"freefrom.space/nobot/core/twitterfetchhistory"
	"freefrom.space/nobot/core/twitternote"
	"freefrom.space/nobot/core/twitternotesfetchhistory"
	"freefrom.space/nobot/core/twitterprofile"

	stdsql "database/sql"

	"freefrom.space/nobot/core/internal"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// BotEvents is the client for interacting with the BotEvents builders.
	BotEvents *BotEventsClient
	// Events is the client for interacting with the Events builders.
	Events *EventsClient
	// NostrNotesFetchHistory is the client for interacting with the NostrNotesFetchHistory builders.
	NostrNotesFetchHistory *NostrNotesFetchHistoryClient
	// TwitterFetchHistory is the client for interacting with the TwitterFetchHistory builders.
	TwitterFetchHistory *TwitterFetchHistoryClient
	// TwitterNote is the client for interacting with the TwitterNote builders.
	TwitterNote *TwitterNoteClient
	// TwitterNotesFetchHistory is the client for interacting with the TwitterNotesFetchHistory builders.
	TwitterNotesFetchHistory *TwitterNotesFetchHistoryClient
	// TwitterProfile is the client for interacting with the TwitterProfile builders.
	TwitterProfile *TwitterProfileClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.BotEvents = NewBotEventsClient(c.config)
	c.Events = NewEventsClient(c.config)
	c.NostrNotesFetchHistory = NewNostrNotesFetchHistoryClient(c.config)
	c.TwitterFetchHistory = NewTwitterFetchHistoryClient(c.config)
	c.TwitterNote = NewTwitterNoteClient(c.config)
	c.TwitterNotesFetchHistory = NewTwitterNotesFetchHistoryClient(c.config)
	c.TwitterProfile = NewTwitterProfileClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
		// schemaConfig contains alternative names for all tables.
		schemaConfig SchemaConfig
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("core: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("core: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                      ctx,
		config:                   cfg,
		BotEvents:                NewBotEventsClient(cfg),
		Events:                   NewEventsClient(cfg),
		NostrNotesFetchHistory:   NewNostrNotesFetchHistoryClient(cfg),
		TwitterFetchHistory:      NewTwitterFetchHistoryClient(cfg),
		TwitterNote:              NewTwitterNoteClient(cfg),
		TwitterNotesFetchHistory: NewTwitterNotesFetchHistoryClient(cfg),
		TwitterProfile:           NewTwitterProfileClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                      ctx,
		config:                   cfg,
		BotEvents:                NewBotEventsClient(cfg),
		Events:                   NewEventsClient(cfg),
		NostrNotesFetchHistory:   NewNostrNotesFetchHistoryClient(cfg),
		TwitterFetchHistory:      NewTwitterFetchHistoryClient(cfg),
		TwitterNote:              NewTwitterNoteClient(cfg),
		TwitterNotesFetchHistory: NewTwitterNotesFetchHistoryClient(cfg),
		TwitterProfile:           NewTwitterProfileClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		BotEvents.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.BotEvents, c.Events, c.NostrNotesFetchHistory, c.TwitterFetchHistory,
		c.TwitterNote, c.TwitterNotesFetchHistory, c.TwitterProfile,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.BotEvents, c.Events, c.NostrNotesFetchHistory, c.TwitterFetchHistory,
		c.TwitterNote, c.TwitterNotesFetchHistory, c.TwitterProfile,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *BotEventsMutation:
		return c.BotEvents.mutate(ctx, m)
	case *EventsMutation:
		return c.Events.mutate(ctx, m)
	case *NostrNotesFetchHistoryMutation:
		return c.NostrNotesFetchHistory.mutate(ctx, m)
	case *TwitterFetchHistoryMutation:
		return c.TwitterFetchHistory.mutate(ctx, m)
	case *TwitterNoteMutation:
		return c.TwitterNote.mutate(ctx, m)
	case *TwitterNotesFetchHistoryMutation:
		return c.TwitterNotesFetchHistory.mutate(ctx, m)
	case *TwitterProfileMutation:
		return c.TwitterProfile.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("core: unknown mutation type %T", m)
	}
}

// BotEventsClient is a client for the BotEvents schema.
type BotEventsClient struct {
	config
}

// NewBotEventsClient returns a client for the BotEvents from the given config.
func NewBotEventsClient(c config) *BotEventsClient {
	return &BotEventsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `botevents.Hooks(f(g(h())))`.
func (c *BotEventsClient) Use(hooks ...Hook) {
	c.hooks.BotEvents = append(c.hooks.BotEvents, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `botevents.Intercept(f(g(h())))`.
func (c *BotEventsClient) Intercept(interceptors ...Interceptor) {
	c.inters.BotEvents = append(c.inters.BotEvents, interceptors...)
}

// Create returns a builder for creating a BotEvents entity.
func (c *BotEventsClient) Create() *BotEventsCreate {
	mutation := newBotEventsMutation(c.config, OpCreate)
	return &BotEventsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BotEvents entities.
func (c *BotEventsClient) CreateBulk(builders ...*BotEventsCreate) *BotEventsCreateBulk {
	return &BotEventsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BotEventsClient) MapCreateBulk(slice any, setFunc func(*BotEventsCreate, int)) *BotEventsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BotEventsCreateBulk{err: fmt.Errorf("calling to BotEventsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BotEventsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BotEventsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BotEvents.
func (c *BotEventsClient) Update() *BotEventsUpdate {
	mutation := newBotEventsMutation(c.config, OpUpdate)
	return &BotEventsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BotEventsClient) UpdateOne(be *BotEvents) *BotEventsUpdateOne {
	mutation := newBotEventsMutation(c.config, OpUpdateOne, withBotEvents(be))
	return &BotEventsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BotEventsClient) UpdateOneID(id int) *BotEventsUpdateOne {
	mutation := newBotEventsMutation(c.config, OpUpdateOne, withBotEventsID(id))
	return &BotEventsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BotEvents.
func (c *BotEventsClient) Delete() *BotEventsDelete {
	mutation := newBotEventsMutation(c.config, OpDelete)
	return &BotEventsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BotEventsClient) DeleteOne(be *BotEvents) *BotEventsDeleteOne {
	return c.DeleteOneID(be.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BotEventsClient) DeleteOneID(id int) *BotEventsDeleteOne {
	builder := c.Delete().Where(botevents.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BotEventsDeleteOne{builder}
}

// Query returns a query builder for BotEvents.
func (c *BotEventsClient) Query() *BotEventsQuery {
	return &BotEventsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBotEvents},
		inters: c.Interceptors(),
	}
}

// Get returns a BotEvents entity by its id.
func (c *BotEventsClient) Get(ctx context.Context, id int) (*BotEvents, error) {
	return c.Query().Where(botevents.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BotEventsClient) GetX(ctx context.Context, id int) *BotEvents {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *BotEventsClient) Hooks() []Hook {
	return c.hooks.BotEvents
}

// Interceptors returns the client interceptors.
func (c *BotEventsClient) Interceptors() []Interceptor {
	return c.inters.BotEvents
}

func (c *BotEventsClient) mutate(ctx context.Context, m *BotEventsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BotEventsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BotEventsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BotEventsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BotEventsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("core: unknown BotEvents mutation op: %q", m.Op())
	}
}

// EventsClient is a client for the Events schema.
type EventsClient struct {
	config
}

// NewEventsClient returns a client for the Events from the given config.
func NewEventsClient(c config) *EventsClient {
	return &EventsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `events.Hooks(f(g(h())))`.
func (c *EventsClient) Use(hooks ...Hook) {
	c.hooks.Events = append(c.hooks.Events, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `events.Intercept(f(g(h())))`.
func (c *EventsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Events = append(c.inters.Events, interceptors...)
}

// Create returns a builder for creating a Events entity.
func (c *EventsClient) Create() *EventsCreate {
	mutation := newEventsMutation(c.config, OpCreate)
	return &EventsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Events entities.
func (c *EventsClient) CreateBulk(builders ...*EventsCreate) *EventsCreateBulk {
	return &EventsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EventsClient) MapCreateBulk(slice any, setFunc func(*EventsCreate, int)) *EventsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EventsCreateBulk{err: fmt.Errorf("calling to EventsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EventsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EventsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Events.
func (c *EventsClient) Update() *EventsUpdate {
	mutation := newEventsMutation(c.config, OpUpdate)
	return &EventsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EventsClient) UpdateOne(e *Events) *EventsUpdateOne {
	mutation := newEventsMutation(c.config, OpUpdateOne, withEvents(e))
	return &EventsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EventsClient) UpdateOneID(id int64) *EventsUpdateOne {
	mutation := newEventsMutation(c.config, OpUpdateOne, withEventsID(id))
	return &EventsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Events.
func (c *EventsClient) Delete() *EventsDelete {
	mutation := newEventsMutation(c.config, OpDelete)
	return &EventsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EventsClient) DeleteOne(e *Events) *EventsDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EventsClient) DeleteOneID(id int64) *EventsDeleteOne {
	builder := c.Delete().Where(events.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EventsDeleteOne{builder}
}

// Query returns a query builder for Events.
func (c *EventsClient) Query() *EventsQuery {
	return &EventsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEvents},
		inters: c.Interceptors(),
	}
}

// Get returns a Events entity by its id.
func (c *EventsClient) Get(ctx context.Context, id int64) (*Events, error) {
	return c.Query().Where(events.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EventsClient) GetX(ctx context.Context, id int64) *Events {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EventsClient) Hooks() []Hook {
	return c.hooks.Events
}

// Interceptors returns the client interceptors.
func (c *EventsClient) Interceptors() []Interceptor {
	return c.inters.Events
}

func (c *EventsClient) mutate(ctx context.Context, m *EventsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EventsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EventsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EventsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EventsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("core: unknown Events mutation op: %q", m.Op())
	}
}

// NostrNotesFetchHistoryClient is a client for the NostrNotesFetchHistory schema.
type NostrNotesFetchHistoryClient struct {
	config
}

// NewNostrNotesFetchHistoryClient returns a client for the NostrNotesFetchHistory from the given config.
func NewNostrNotesFetchHistoryClient(c config) *NostrNotesFetchHistoryClient {
	return &NostrNotesFetchHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `nostrnotesfetchhistory.Hooks(f(g(h())))`.
func (c *NostrNotesFetchHistoryClient) Use(hooks ...Hook) {
	c.hooks.NostrNotesFetchHistory = append(c.hooks.NostrNotesFetchHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `nostrnotesfetchhistory.Intercept(f(g(h())))`.
func (c *NostrNotesFetchHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.NostrNotesFetchHistory = append(c.inters.NostrNotesFetchHistory, interceptors...)
}

// Create returns a builder for creating a NostrNotesFetchHistory entity.
func (c *NostrNotesFetchHistoryClient) Create() *NostrNotesFetchHistoryCreate {
	mutation := newNostrNotesFetchHistoryMutation(c.config, OpCreate)
	return &NostrNotesFetchHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of NostrNotesFetchHistory entities.
func (c *NostrNotesFetchHistoryClient) CreateBulk(builders ...*NostrNotesFetchHistoryCreate) *NostrNotesFetchHistoryCreateBulk {
	return &NostrNotesFetchHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NostrNotesFetchHistoryClient) MapCreateBulk(slice any, setFunc func(*NostrNotesFetchHistoryCreate, int)) *NostrNotesFetchHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NostrNotesFetchHistoryCreateBulk{err: fmt.Errorf("calling to NostrNotesFetchHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NostrNotesFetchHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NostrNotesFetchHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for NostrNotesFetchHistory.
func (c *NostrNotesFetchHistoryClient) Update() *NostrNotesFetchHistoryUpdate {
	mutation := newNostrNotesFetchHistoryMutation(c.config, OpUpdate)
	return &NostrNotesFetchHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NostrNotesFetchHistoryClient) UpdateOne(nnfh *NostrNotesFetchHistory) *NostrNotesFetchHistoryUpdateOne {
	mutation := newNostrNotesFetchHistoryMutation(c.config, OpUpdateOne, withNostrNotesFetchHistory(nnfh))
	return &NostrNotesFetchHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NostrNotesFetchHistoryClient) UpdateOneID(id string) *NostrNotesFetchHistoryUpdateOne {
	mutation := newNostrNotesFetchHistoryMutation(c.config, OpUpdateOne, withNostrNotesFetchHistoryID(id))
	return &NostrNotesFetchHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for NostrNotesFetchHistory.
func (c *NostrNotesFetchHistoryClient) Delete() *NostrNotesFetchHistoryDelete {
	mutation := newNostrNotesFetchHistoryMutation(c.config, OpDelete)
	return &NostrNotesFetchHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NostrNotesFetchHistoryClient) DeleteOne(nnfh *NostrNotesFetchHistory) *NostrNotesFetchHistoryDeleteOne {
	return c.DeleteOneID(nnfh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NostrNotesFetchHistoryClient) DeleteOneID(id string) *NostrNotesFetchHistoryDeleteOne {
	builder := c.Delete().Where(nostrnotesfetchhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NostrNotesFetchHistoryDeleteOne{builder}
}

// Query returns a query builder for NostrNotesFetchHistory.
func (c *NostrNotesFetchHistoryClient) Query() *NostrNotesFetchHistoryQuery {
	return &NostrNotesFetchHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNostrNotesFetchHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a NostrNotesFetchHistory entity by its id.
func (c *NostrNotesFetchHistoryClient) Get(ctx context.Context, id string) (*NostrNotesFetchHistory, error) {
	return c.Query().Where(nostrnotesfetchhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NostrNotesFetchHistoryClient) GetX(ctx context.Context, id string) *NostrNotesFetchHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *NostrNotesFetchHistoryClient) Hooks() []Hook {
	return c.hooks.NostrNotesFetchHistory
}

// Interceptors returns the client interceptors.
func (c *NostrNotesFetchHistoryClient) Interceptors() []Interceptor {
	return c.inters.NostrNotesFetchHistory
}

func (c *NostrNotesFetchHistoryClient) mutate(ctx context.Context, m *NostrNotesFetchHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NostrNotesFetchHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NostrNotesFetchHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NostrNotesFetchHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NostrNotesFetchHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("core: unknown NostrNotesFetchHistory mutation op: %q", m.Op())
	}
}

// TwitterFetchHistoryClient is a client for the TwitterFetchHistory schema.
type TwitterFetchHistoryClient struct {
	config
}

// NewTwitterFetchHistoryClient returns a client for the TwitterFetchHistory from the given config.
func NewTwitterFetchHistoryClient(c config) *TwitterFetchHistoryClient {
	return &TwitterFetchHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `twitterfetchhistory.Hooks(f(g(h())))`.
func (c *TwitterFetchHistoryClient) Use(hooks ...Hook) {
	c.hooks.TwitterFetchHistory = append(c.hooks.TwitterFetchHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `twitterfetchhistory.Intercept(f(g(h())))`.
func (c *TwitterFetchHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.TwitterFetchHistory = append(c.inters.TwitterFetchHistory, interceptors...)
}

// Create returns a builder for creating a TwitterFetchHistory entity.
func (c *TwitterFetchHistoryClient) Create() *TwitterFetchHistoryCreate {
	mutation := newTwitterFetchHistoryMutation(c.config, OpCreate)
	return &TwitterFetchHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TwitterFetchHistory entities.
func (c *TwitterFetchHistoryClient) CreateBulk(builders ...*TwitterFetchHistoryCreate) *TwitterFetchHistoryCreateBulk {
	return &TwitterFetchHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TwitterFetchHistoryClient) MapCreateBulk(slice any, setFunc func(*TwitterFetchHistoryCreate, int)) *TwitterFetchHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TwitterFetchHistoryCreateBulk{err: fmt.Errorf("calling to TwitterFetchHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TwitterFetchHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TwitterFetchHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TwitterFetchHistory.
func (c *TwitterFetchHistoryClient) Update() *TwitterFetchHistoryUpdate {
	mutation := newTwitterFetchHistoryMutation(c.config, OpUpdate)
	return &TwitterFetchHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TwitterFetchHistoryClient) UpdateOne(tfh *TwitterFetchHistory) *TwitterFetchHistoryUpdateOne {
	mutation := newTwitterFetchHistoryMutation(c.config, OpUpdateOne, withTwitterFetchHistory(tfh))
	return &TwitterFetchHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TwitterFetchHistoryClient) UpdateOneID(id int) *TwitterFetchHistoryUpdateOne {
	mutation := newTwitterFetchHistoryMutation(c.config, OpUpdateOne, withTwitterFetchHistoryID(id))
	return &TwitterFetchHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TwitterFetchHistory.
func (c *TwitterFetchHistoryClient) Delete() *TwitterFetchHistoryDelete {
	mutation := newTwitterFetchHistoryMutation(c.config, OpDelete)
	return &TwitterFetchHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TwitterFetchHistoryClient) DeleteOne(tfh *TwitterFetchHistory) *TwitterFetchHistoryDeleteOne {
	return c.DeleteOneID(tfh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TwitterFetchHistoryClient) DeleteOneID(id int) *TwitterFetchHistoryDeleteOne {
	builder := c.Delete().Where(twitterfetchhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TwitterFetchHistoryDeleteOne{builder}
}

// Query returns a query builder for TwitterFetchHistory.
func (c *TwitterFetchHistoryClient) Query() *TwitterFetchHistoryQuery {
	return &TwitterFetchHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTwitterFetchHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a TwitterFetchHistory entity by its id.
func (c *TwitterFetchHistoryClient) Get(ctx context.Context, id int) (*TwitterFetchHistory, error) {
	return c.Query().Where(twitterfetchhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TwitterFetchHistoryClient) GetX(ctx context.Context, id int) *TwitterFetchHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TwitterFetchHistoryClient) Hooks() []Hook {
	return c.hooks.TwitterFetchHistory
}

// Interceptors returns the client interceptors.
func (c *TwitterFetchHistoryClient) Interceptors() []Interceptor {
	return c.inters.TwitterFetchHistory
}

func (c *TwitterFetchHistoryClient) mutate(ctx context.Context, m *TwitterFetchHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TwitterFetchHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TwitterFetchHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TwitterFetchHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TwitterFetchHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("core: unknown TwitterFetchHistory mutation op: %q", m.Op())
	}
}

// TwitterNoteClient is a client for the TwitterNote schema.
type TwitterNoteClient struct {
	config
}

// NewTwitterNoteClient returns a client for the TwitterNote from the given config.
func NewTwitterNoteClient(c config) *TwitterNoteClient {
	return &TwitterNoteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `twitternote.Hooks(f(g(h())))`.
func (c *TwitterNoteClient) Use(hooks ...Hook) {
	c.hooks.TwitterNote = append(c.hooks.TwitterNote, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `twitternote.Intercept(f(g(h())))`.
func (c *TwitterNoteClient) Intercept(interceptors ...Interceptor) {
	c.inters.TwitterNote = append(c.inters.TwitterNote, interceptors...)
}

// Create returns a builder for creating a TwitterNote entity.
func (c *TwitterNoteClient) Create() *TwitterNoteCreate {
	mutation := newTwitterNoteMutation(c.config, OpCreate)
	return &TwitterNoteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TwitterNote entities.
func (c *TwitterNoteClient) CreateBulk(builders ...*TwitterNoteCreate) *TwitterNoteCreateBulk {
	return &TwitterNoteCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TwitterNoteClient) MapCreateBulk(slice any, setFunc func(*TwitterNoteCreate, int)) *TwitterNoteCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TwitterNoteCreateBulk{err: fmt.Errorf("calling to TwitterNoteClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TwitterNoteCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TwitterNoteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TwitterNote.
func (c *TwitterNoteClient) Update() *TwitterNoteUpdate {
	mutation := newTwitterNoteMutation(c.config, OpUpdate)
	return &TwitterNoteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TwitterNoteClient) UpdateOne(tn *TwitterNote) *TwitterNoteUpdateOne {
	mutation := newTwitterNoteMutation(c.config, OpUpdateOne, withTwitterNote(tn))
	return &TwitterNoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TwitterNoteClient) UpdateOneID(id string) *TwitterNoteUpdateOne {
	mutation := newTwitterNoteMutation(c.config, OpUpdateOne, withTwitterNoteID(id))
	return &TwitterNoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TwitterNote.
func (c *TwitterNoteClient) Delete() *TwitterNoteDelete {
	mutation := newTwitterNoteMutation(c.config, OpDelete)
	return &TwitterNoteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TwitterNoteClient) DeleteOne(tn *TwitterNote) *TwitterNoteDeleteOne {
	return c.DeleteOneID(tn.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TwitterNoteClient) DeleteOneID(id string) *TwitterNoteDeleteOne {
	builder := c.Delete().Where(twitternote.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TwitterNoteDeleteOne{builder}
}

// Query returns a query builder for TwitterNote.
func (c *TwitterNoteClient) Query() *TwitterNoteQuery {
	return &TwitterNoteQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTwitterNote},
		inters: c.Interceptors(),
	}
}

// Get returns a TwitterNote entity by its id.
func (c *TwitterNoteClient) Get(ctx context.Context, id string) (*TwitterNote, error) {
	return c.Query().Where(twitternote.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TwitterNoteClient) GetX(ctx context.Context, id string) *TwitterNote {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TwitterNoteClient) Hooks() []Hook {
	return c.hooks.TwitterNote
}

// Interceptors returns the client interceptors.
func (c *TwitterNoteClient) Interceptors() []Interceptor {
	return c.inters.TwitterNote
}

func (c *TwitterNoteClient) mutate(ctx context.Context, m *TwitterNoteMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TwitterNoteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TwitterNoteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TwitterNoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TwitterNoteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("core: unknown TwitterNote mutation op: %q", m.Op())
	}
}

// TwitterNotesFetchHistoryClient is a client for the TwitterNotesFetchHistory schema.
type TwitterNotesFetchHistoryClient struct {
	config
}

// NewTwitterNotesFetchHistoryClient returns a client for the TwitterNotesFetchHistory from the given config.
func NewTwitterNotesFetchHistoryClient(c config) *TwitterNotesFetchHistoryClient {
	return &TwitterNotesFetchHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `twitternotesfetchhistory.Hooks(f(g(h())))`.
func (c *TwitterNotesFetchHistoryClient) Use(hooks ...Hook) {
	c.hooks.TwitterNotesFetchHistory = append(c.hooks.TwitterNotesFetchHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `twitternotesfetchhistory.Intercept(f(g(h())))`.
func (c *TwitterNotesFetchHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.TwitterNotesFetchHistory = append(c.inters.TwitterNotesFetchHistory, interceptors...)
}

// Create returns a builder for creating a TwitterNotesFetchHistory entity.
func (c *TwitterNotesFetchHistoryClient) Create() *TwitterNotesFetchHistoryCreate {
	mutation := newTwitterNotesFetchHistoryMutation(c.config, OpCreate)
	return &TwitterNotesFetchHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TwitterNotesFetchHistory entities.
func (c *TwitterNotesFetchHistoryClient) CreateBulk(builders ...*TwitterNotesFetchHistoryCreate) *TwitterNotesFetchHistoryCreateBulk {
	return &TwitterNotesFetchHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TwitterNotesFetchHistoryClient) MapCreateBulk(slice any, setFunc func(*TwitterNotesFetchHistoryCreate, int)) *TwitterNotesFetchHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TwitterNotesFetchHistoryCreateBulk{err: fmt.Errorf("calling to TwitterNotesFetchHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TwitterNotesFetchHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TwitterNotesFetchHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TwitterNotesFetchHistory.
func (c *TwitterNotesFetchHistoryClient) Update() *TwitterNotesFetchHistoryUpdate {
	mutation := newTwitterNotesFetchHistoryMutation(c.config, OpUpdate)
	return &TwitterNotesFetchHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TwitterNotesFetchHistoryClient) UpdateOne(tnfh *TwitterNotesFetchHistory) *TwitterNotesFetchHistoryUpdateOne {
	mutation := newTwitterNotesFetchHistoryMutation(c.config, OpUpdateOne, withTwitterNotesFetchHistory(tnfh))
	return &TwitterNotesFetchHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TwitterNotesFetchHistoryClient) UpdateOneID(id int64) *TwitterNotesFetchHistoryUpdateOne {
	mutation := newTwitterNotesFetchHistoryMutation(c.config, OpUpdateOne, withTwitterNotesFetchHistoryID(id))
	return &TwitterNotesFetchHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TwitterNotesFetchHistory.
func (c *TwitterNotesFetchHistoryClient) Delete() *TwitterNotesFetchHistoryDelete {
	mutation := newTwitterNotesFetchHistoryMutation(c.config, OpDelete)
	return &TwitterNotesFetchHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TwitterNotesFetchHistoryClient) DeleteOne(tnfh *TwitterNotesFetchHistory) *TwitterNotesFetchHistoryDeleteOne {
	return c.DeleteOneID(tnfh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TwitterNotesFetchHistoryClient) DeleteOneID(id int64) *TwitterNotesFetchHistoryDeleteOne {
	builder := c.Delete().Where(twitternotesfetchhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TwitterNotesFetchHistoryDeleteOne{builder}
}

// Query returns a query builder for TwitterNotesFetchHistory.
func (c *TwitterNotesFetchHistoryClient) Query() *TwitterNotesFetchHistoryQuery {
	return &TwitterNotesFetchHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTwitterNotesFetchHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a TwitterNotesFetchHistory entity by its id.
func (c *TwitterNotesFetchHistoryClient) Get(ctx context.Context, id int64) (*TwitterNotesFetchHistory, error) {
	return c.Query().Where(twitternotesfetchhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TwitterNotesFetchHistoryClient) GetX(ctx context.Context, id int64) *TwitterNotesFetchHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TwitterNotesFetchHistoryClient) Hooks() []Hook {
	return c.hooks.TwitterNotesFetchHistory
}

// Interceptors returns the client interceptors.
func (c *TwitterNotesFetchHistoryClient) Interceptors() []Interceptor {
	return c.inters.TwitterNotesFetchHistory
}

func (c *TwitterNotesFetchHistoryClient) mutate(ctx context.Context, m *TwitterNotesFetchHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TwitterNotesFetchHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TwitterNotesFetchHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TwitterNotesFetchHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TwitterNotesFetchHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("core: unknown TwitterNotesFetchHistory mutation op: %q", m.Op())
	}
}

// TwitterProfileClient is a client for the TwitterProfile schema.
type TwitterProfileClient struct {
	config
}

// NewTwitterProfileClient returns a client for the TwitterProfile from the given config.
func NewTwitterProfileClient(c config) *TwitterProfileClient {
	return &TwitterProfileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `twitterprofile.Hooks(f(g(h())))`.
func (c *TwitterProfileClient) Use(hooks ...Hook) {
	c.hooks.TwitterProfile = append(c.hooks.TwitterProfile, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `twitterprofile.Intercept(f(g(h())))`.
func (c *TwitterProfileClient) Intercept(interceptors ...Interceptor) {
	c.inters.TwitterProfile = append(c.inters.TwitterProfile, interceptors...)
}

// Create returns a builder for creating a TwitterProfile entity.
func (c *TwitterProfileClient) Create() *TwitterProfileCreate {
	mutation := newTwitterProfileMutation(c.config, OpCreate)
	return &TwitterProfileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TwitterProfile entities.
func (c *TwitterProfileClient) CreateBulk(builders ...*TwitterProfileCreate) *TwitterProfileCreateBulk {
	return &TwitterProfileCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TwitterProfileClient) MapCreateBulk(slice any, setFunc func(*TwitterProfileCreate, int)) *TwitterProfileCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TwitterProfileCreateBulk{err: fmt.Errorf("calling to TwitterProfileClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TwitterProfileCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TwitterProfileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TwitterProfile.
func (c *TwitterProfileClient) Update() *TwitterProfileUpdate {
	mutation := newTwitterProfileMutation(c.config, OpUpdate)
	return &TwitterProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TwitterProfileClient) UpdateOne(tp *TwitterProfile) *TwitterProfileUpdateOne {
	mutation := newTwitterProfileMutation(c.config, OpUpdateOne, withTwitterProfile(tp))
	return &TwitterProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TwitterProfileClient) UpdateOneID(id int) *TwitterProfileUpdateOne {
	mutation := newTwitterProfileMutation(c.config, OpUpdateOne, withTwitterProfileID(id))
	return &TwitterProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TwitterProfile.
func (c *TwitterProfileClient) Delete() *TwitterProfileDelete {
	mutation := newTwitterProfileMutation(c.config, OpDelete)
	return &TwitterProfileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TwitterProfileClient) DeleteOne(tp *TwitterProfile) *TwitterProfileDeleteOne {
	return c.DeleteOneID(tp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TwitterProfileClient) DeleteOneID(id int) *TwitterProfileDeleteOne {
	builder := c.Delete().Where(twitterprofile.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TwitterProfileDeleteOne{builder}
}

// Query returns a query builder for TwitterProfile.
func (c *TwitterProfileClient) Query() *TwitterProfileQuery {
	return &TwitterProfileQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTwitterProfile},
		inters: c.Interceptors(),
	}
}

// Get returns a TwitterProfile entity by its id.
func (c *TwitterProfileClient) Get(ctx context.Context, id int) (*TwitterProfile, error) {
	return c.Query().Where(twitterprofile.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TwitterProfileClient) GetX(ctx context.Context, id int) *TwitterProfile {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TwitterProfileClient) Hooks() []Hook {
	return c.hooks.TwitterProfile
}

// Interceptors returns the client interceptors.
func (c *TwitterProfileClient) Interceptors() []Interceptor {
	return c.inters.TwitterProfile
}

func (c *TwitterProfileClient) mutate(ctx context.Context, m *TwitterProfileMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TwitterProfileCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TwitterProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TwitterProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TwitterProfileDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("core: unknown TwitterProfile mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		BotEvents, Events, NostrNotesFetchHistory, TwitterFetchHistory, TwitterNote,
		TwitterNotesFetchHistory, TwitterProfile []ent.Hook
	}
	inters struct {
		BotEvents, Events, NostrNotesFetchHistory, TwitterFetchHistory, TwitterNote,
		TwitterNotesFetchHistory, TwitterProfile []ent.Interceptor
	}
)

// SchemaConfig represents alternative schema names for all tables
// that can be passed at runtime.
type SchemaConfig = internal.SchemaConfig

// AlternateSchemas allows alternate schema names to be
// passed into ent operations.
func AlternateSchema(schemaConfig SchemaConfig) Option {
	return func(c *config) {
		c.schemaConfig = schemaConfig
	}
}

// ExecContext allows calling the underlying ExecContext method of the driver if it is supported by it.
// See, database/sql#DB.ExecContext for more information.
func (c *config) ExecContext(ctx context.Context, query string, args ...any) (stdsql.Result, error) {
	ex, ok := c.driver.(interface {
		ExecContext(context.Context, string, ...any) (stdsql.Result, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.ExecContext is not supported")
	}
	return ex.ExecContext(ctx, query, args...)
}

// QueryContext allows calling the underlying QueryContext method of the driver if it is supported by it.
// See, database/sql#DB.QueryContext for more information.
func (c *config) QueryContext(ctx context.Context, query string, args ...any) (*stdsql.Rows, error) {
	q, ok := c.driver.(interface {
		QueryContext(context.Context, string, ...any) (*stdsql.Rows, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.QueryContext is not supported")
	}
	return q.QueryContext(ctx, query, args...)
}
